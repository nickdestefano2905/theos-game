<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Theo's Game - Survive to 30!</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #111; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
  canvas { display: block; image-rendering: pixelated; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
// ============================================================
// THEO'S GAME — Survive to 30!
// A side-scrolling platformer set in cartoon Boston
// ============================================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// --- Responsive canvas ---
function resizeCanvas() {
  canvas.width = Math.min(window.innerWidth, 1200);
  canvas.height = Math.min(window.innerHeight, 700);
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// --- Constants ---
const GRAVITY = 0.55;
const GROUND_Y_OFFSET = 80; // ground from bottom
const MAX_FALL_SPEED = 14;
const COIN_SIZE = 16;
const AGE_DURATION = 10; // seconds per year of age
const WIN_AGE = 30;

// --- Game State ---
let gameState = 'menu'; // menu, playing, gameover, victory
let gameTime = 0;
let age = 0;
let coins = 0;
let deathMessage = '';
let cameraX = 0;
let lastTime = 0;
let platforms = [];
let buildings = [];
let coinList = [];
let enemies = [];
let particles = [];
let waterZones = [];
let clouds = [];
let generatedUpTo = 0;
let difficultyMult = 1;
let screenShake = 0;
let godzillaWarningTimer = 0;
let invincibleTimer = 0;

// --- Input ---
const keys = {};
window.addEventListener('keydown', e => { keys[e.code] = true; if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.code] = false; });

// --- Player ---
let player = {
  x: 200, y: 0, vx: 0, vy: 0,
  width: 20, height: 36,
  onGround: false, jumpHeld: false,
  facing: 1, // 1=right, -1=left
  walkFrame: 0, walkTimer: 0,
  alive: true
};

function groundY() { return canvas.height - GROUND_Y_OFFSET; }

// --- Utility ---
function rand(a, b) { return Math.random() * (b - a) + a; }
function randInt(a, b) { return Math.floor(rand(a, b + 1)); }
function lerp(a, b, t) { return a + (b - a) * t; }
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
function rectOverlap(a, b) {
  return a.x < b.x + b.width && a.x + a.width > b.x &&
         a.y < b.y + b.height && a.y + a.height > b.y;
}

// --- Color Helpers ---
function skyColor() {
  // Gradually shift sky as age increases
  let r = lerp(135, 90, age / 30);
  let g = lerp(206, 150, age / 30);
  let b = lerp(250, 220, age / 30);
  return `rgb(${r|0},${g|0},${b|0})`;
}

// --- Character Stage ---
function getStage() {
  if (age < 13) return 'child';
  if (age < 18) return 'teen';
  if (age < 25) return 'youngadult';
  return 'adult';
}

function getPlayerSize() {
  switch (getStage()) {
    case 'child': return { w: 16, h: 28 };
    case 'teen': return { w: 18, h: 34 };
    case 'youngadult': return { w: 20, h: 38 };
    case 'adult': return { w: 22, h: 40 };
  }
}

// --- Procedural Generation ---
function generateWorld(fromX, toX) {
  // Buildings
  let bx = fromX;
  while (bx < toX) {
    let bw = randInt(80, 160);
    let bh = randInt(120, 250 + age * 3);
    let floors = Math.floor(bh / 40);
    let color = ['#8B4513','#A0522D','#CD853F','#B22222','#D2691E','#A52A2A'][randInt(0, 5)];
    let by = groundY() - bh;
    buildings.push({ x: bx, y: by, w: bw, h: bh, floors, color, windows: [] });

    // Windows
    let winCols = Math.floor((bw - 20) / 28);
    let winRows = Math.floor((bh - 20) / 40);
    for (let r = 0; r < winRows; r++) {
      for (let c = 0; c < winCols; c++) {
        buildings[buildings.length - 1].windows.push({
          x: 14 + c * 28,
          y: 14 + r * 40,
          lit: Math.random() > 0.4
        });
      }
    }

    // Rooftop platform
    platforms.push({ x: bx + 10, y: by - 4, w: bw - 20, h: 8, type: 'roof' });

    // Mid-level platforms (fire escapes / ledges)
    if (bh > 150 && Math.random() > 0.3) {
      let py = by + bh * 0.4;
      platforms.push({ x: bx - 20, y: py, w: 50, h: 8, type: 'ledge' });
    }
    if (bh > 200 && Math.random() > 0.4) {
      let py = by + bh * 0.65;
      platforms.push({ x: bx + bw - 30, y: py, w: 50, h: 8, type: 'ledge' });
    }

    // Floating platforms between buildings
    if (Math.random() > 0.5) {
      let px = bx + bw + randInt(10, 40);
      let py = groundY() - randInt(80, 180);
      platforms.push({ x: px, y: py, w: randInt(50, 80), h: 8, type: 'float' });
    }

    // Coins on rooftops
    for (let i = 0; i < randInt(1, 4); i++) {
      coinList.push({ x: bx + randInt(20, bw - 20), y: by - 20, collected: false });
    }

    // Street-level coins
    for (let i = 0; i < randInt(0, 3); i++) {
      coinList.push({ x: bx + randInt(0, bw), y: groundY() - 20, collected: false });
    }

    // Floating coins
    if (Math.random() > 0.4) {
      let cy = groundY() - randInt(100, 200);
      for (let i = 0; i < randInt(2, 5); i++) {
        coinList.push({ x: bx + bw + 20 + i * 24, y: cy, collected: false });
      }
    }

    // Water zones (Boston Harbor)
    if (Math.random() > 0.85) {
      let wx = bx + bw + 10;
      let ww = randInt(80, 150);
      waterZones.push({ x: wx, y: groundY() - 10, w: ww, h: 30, waveOffset: rand(0, Math.PI * 2) });
      bx = wx + ww + 10;
      continue;
    }

    bx += bw + randInt(40, 100);
  }

  // Enemies — keep a safe zone around the player start position
  let enemySafeZone = 700;
  let ex = Math.max(fromX + 400, enemySafeZone);
  while (ex < toX) {
    let gap = Math.max(200, 600 - age * 12);
    let type = Math.random();
    if (type < 0.5) {
      enemies.push(createBigfoot(ex));
    } else if (type < 0.85) {
      // Nessie — place near water or just in the ground area
      enemies.push(createNessie(ex));
    } else {
      // Godzilla — rare
      if (age >= 5) {
        enemies.push(createGodzilla(ex));
      } else {
        enemies.push(createBigfoot(ex));
      }
    }
    ex += randInt(gap, gap + 300);
  }

  // Clouds
  for (let cx = fromX; cx < toX; cx += randInt(200, 400)) {
    clouds.push({ x: cx, y: randInt(20, 120), w: randInt(60, 140), h: randInt(25, 45), speed: rand(0.1, 0.4) });
  }
}

function createBigfoot(x) {
  return {
    type: 'bigfoot', x, y: groundY() - 50, w: 40, h: 50,
    vx: rand(0.8, 1.5) * difficultyMult * (Math.random() > 0.5 ? 1 : -1),
    frame: 0, timer: 0, onRoof: Math.random() > 0.6,
    baseY: 0
  };
}

function createNessie(x) {
  return {
    type: 'nessie', x, y: groundY() - 5, w: 60, h: 35,
    vx: 0, bobTimer: rand(0, Math.PI * 2),
    emergeTimer: 0, emerged: false, emergeY: groundY() - 40,
    baseY: groundY() - 5
  };
}

function createGodzilla(x) {
  return {
    type: 'godzilla', x: x + 600, y: groundY() - 180, w: 90, h: 180,
    vx: -0.6 * difficultyMult, frame: 0, timer: 0,
    stompTimer: 0
  };
}

// --- Init / Reset ---
function initGame() {
  gameTime = 0;
  age = 0;
  coins = 0;
  cameraX = 0;
  deathMessage = '';
  platforms = [];
  buildings = [];
  coinList = [];
  enemies = [];
  particles = [];
  waterZones = [];
  clouds = [];
  generatedUpTo = 0;
  difficultyMult = 1;
  screenShake = 0;
  godzillaWarningTimer = 0;
  invincibleTimer = 2.5; // seconds of spawn protection

  player.x = 200;
  player.y = groundY() - 50;
  player.vx = 0;
  player.vy = 0;
  player.onGround = false;
  player.alive = true;
  player.facing = 1;
  player.walkFrame = 0;

  // Ground platform (conceptual, ground is at groundY())
  // Generate initial world
  generateWorld(-200, canvas.width + 800);
  generatedUpTo = canvas.width + 800;
}

// --- Update ---
function update(dt) {
  if (gameState !== 'playing') return;

  gameTime += dt;
  age = Math.min(WIN_AGE, Math.floor(gameTime / AGE_DURATION));
  difficultyMult = 1 + age * 0.05;

  // Spawn invincibility countdown
  if (invincibleTimer > 0) invincibleTimer -= dt;

  // Update player size based on age
  let size = getPlayerSize();
  let oldH = player.height;
  player.width = size.w;
  player.height = size.h;
  if (player.onGround && size.h !== oldH) {
    player.y -= (size.h - oldH);
  }

  // Win condition
  if (age >= WIN_AGE) {
    gameState = 'victory';
    return;
  }

  // --- Player Movement ---
  let moveSpeed = 4.5;
  let accel = player.onGround ? 0.6 : 0.35;
  let friction = player.onGround ? 0.82 : 0.94;

  if (keys['ArrowLeft'] || keys['KeyA']) {
    player.vx -= accel;
    player.facing = -1;
  }
  if (keys['ArrowRight'] || keys['KeyD']) {
    player.vx += accel;
    player.facing = 1;
  }

  player.vx *= friction;
  player.vx = clamp(player.vx, -moveSpeed, moveSpeed);

  // Jump
  let jumpKey = keys['ArrowUp'] || keys['KeyW'] || keys['Space'];
  if (jumpKey && player.onGround && !player.jumpHeld) {
    player.vy = -(11.5 + age * 0.15);
    player.onGround = false;
    player.jumpHeld = true;
    spawnParticles(player.x + player.width / 2, player.y + player.height, 5, '#999');
  }
  // Variable jump height
  if (!jumpKey) {
    player.jumpHeld = false;
    if (player.vy < -3) player.vy *= 0.85;
  }

  // Gravity
  player.vy += GRAVITY;
  if (player.vy > MAX_FALL_SPEED) player.vy = MAX_FALL_SPEED;

  // Move X
  player.x += player.vx;
  // Prevent going too far left
  if (player.x < cameraX - 100) player.x = cameraX - 100;

  // Move Y
  player.y += player.vy;
  player.onGround = false;

  // Ground collision
  if (player.y + player.height >= groundY()) {
    player.y = groundY() - player.height;
    player.vy = 0;
    player.onGround = true;
  }

  // Platform collision
  for (let p of platforms) {
    if (p.x > cameraX + canvas.width + 200 || p.x + p.w < cameraX - 200) continue;
    // Only collide from above
    if (player.vy >= 0 &&
        player.x + player.width > p.x && player.x < p.x + p.w &&
        player.y + player.height >= p.y && player.y + player.height <= p.y + p.h + player.vy + 2) {
      player.y = p.y - player.height;
      player.vy = 0;
      player.onGround = true;
    }
  }

  // Walk animation
  if (Math.abs(player.vx) > 0.5) {
    player.walkTimer += dt * Math.abs(player.vx) * 0.6;
    if (player.walkTimer > 0.12) {
      player.walkTimer = 0;
      player.walkFrame = (player.walkFrame + 1) % 4;
    }
  } else {
    player.walkFrame = 0;
  }

  // --- Camera ---
  let targetCamX = player.x - canvas.width * 0.35;
  cameraX = lerp(cameraX, targetCamX, 0.08);
  if (cameraX < 0) cameraX = 0;

  // --- Generate more world ---
  if (cameraX + canvas.width + 600 > generatedUpTo) {
    generateWorld(generatedUpTo, generatedUpTo + 1200);
    generatedUpTo += 1200;
  }

  // --- Clean up off-screen objects ---
  let cleanX = cameraX - 800;
  buildings = buildings.filter(b => b.x + b.w > cleanX);
  platforms = platforms.filter(p => p.x + p.w > cleanX);
  coinList = coinList.filter(c => c.x > cleanX);
  enemies = enemies.filter(e => e.x + (e.w || 100) > cleanX - 200);
  waterZones = waterZones.filter(w => w.x + w.w > cleanX);
  clouds = clouds.filter(c => c.x + c.w > cleanX - 100);

  // --- Coins ---
  let pr = { x: player.x, y: player.y, width: player.width, height: player.height };
  for (let c of coinList) {
    if (c.collected) continue;
    if (Math.abs(c.x - player.x) < 24 && Math.abs(c.y - player.y) < 30) {
      c.collected = true;
      coins++;
      spawnParticles(c.x, c.y, 6, '#FFD700');
    }
  }

  // --- Enemies ---
  for (let e of enemies) {
    updateEnemy(e, dt);
    // Skip collision while invincible
    if (invincibleTimer > 0) continue;
    // Collision with player
    let eb = { x: e.x, y: e.y, width: e.w, height: e.h };
    if (e.type === 'nessie' && !e.emerged) continue;
    if (rectOverlap(pr, eb)) {
      let names = { bigfoot: 'Bigfoot', nessie: 'the Loch Ness Monster', godzilla: 'Godzilla' };
      deathMessage = `You were eaten by ${names[e.type]}! You made it to age ${age}.`;
      gameState = 'gameover';
      player.alive = false;
      spawnParticles(player.x + player.width / 2, player.y + player.height / 2, 20, '#FF4444');
      return;
    }
  }

  // --- Particles ---
  for (let p of particles) {
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.15;
    p.life -= dt;
  }
  particles = particles.filter(p => p.life > 0);

  // --- Clouds ---
  for (let c of clouds) {
    c.x += c.speed;
  }

  // Screen shake decay
  if (screenShake > 0) screenShake *= 0.9;
  if (screenShake < 0.5) screenShake = 0;
}

function updateEnemy(e, dt) {
  if (e.type === 'bigfoot') {
    e.x += e.vx * difficultyMult;
    e.timer += dt;
    if (e.timer > 0.15) {
      e.timer = 0;
      e.frame = (e.frame + 1) % 4;
    }
    // Keep bigfoot on screen-ish area, bounce at edges
    // Find if on a roof platform
    if (e.onRoof) {
      let onPlat = false;
      for (let p of platforms) {
        if (p.type === 'roof' && e.x + e.w > p.x && e.x < p.x + p.w) {
          e.y = p.y - e.h;
          onPlat = true;
          if (e.x <= p.x || e.x + e.w >= p.x + p.w) e.vx *= -1;
          break;
        }
      }
      if (!onPlat) {
        e.y = groundY() - e.h;
        e.onRoof = false;
      }
    } else {
      e.y = groundY() - e.h;
    }
  }

  if (e.type === 'nessie') {
    e.bobTimer += dt * 2;
    e.emergeTimer += dt;
    // Periodically emerge
    let cycle = (Math.sin(e.bobTimer) + 1) / 2;
    if (cycle > 0.6) {
      e.emerged = true;
      e.y = e.emergeY + Math.sin(e.bobTimer * 1.5) * 8;
    } else {
      e.emerged = false;
      e.y = e.baseY + 20;
    }
  }

  if (e.type === 'godzilla') {
    e.x += e.vx * difficultyMult;
    e.y = groundY() - e.h;
    e.stompTimer += dt;
    if (e.stompTimer > 0.5) {
      e.stompTimer = 0;
      screenShake = 5;
    }
    e.timer += dt;
    if (e.timer > 0.3) {
      e.timer = 0;
      e.frame = (e.frame + 1) % 2;
    }
  }
}

function spawnParticles(x, y, count, color) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: rand(-3, 3), vy: rand(-4, 1),
      life: rand(0.3, 0.8),
      color, size: rand(2, 5)
    });
  }
}

// ============================================================
// RENDERING
// ============================================================

function draw() {
  let shakeX = screenShake ? rand(-screenShake, screenShake) : 0;
  let shakeY = screenShake ? rand(-screenShake, screenShake) : 0;

  ctx.save();
  ctx.translate(shakeX, shakeY);

  // Sky
  ctx.fillStyle = skyColor();
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Clouds (parallax)
  for (let c of clouds) {
    let sx = (c.x - cameraX * 0.3);
    if (sx > -c.w && sx < canvas.width + c.w) {
      drawCloud(sx, c.y, c.w, c.h);
    }
  }

  ctx.save();
  ctx.translate(-cameraX, 0);

  // Water zones
  for (let w of waterZones) {
    drawWater(w);
  }

  // Buildings (background layer)
  for (let b of buildings) {
    if (b.x + b.w < cameraX - 50 || b.x > cameraX + canvas.width + 50) continue;
    drawBuilding(b);
  }

  // Platforms
  for (let p of platforms) {
    if (p.x + p.w < cameraX - 50 || p.x > cameraX + canvas.width + 50) continue;
    drawPlatform(p);
  }

  // Coins
  for (let c of coinList) {
    if (c.collected) continue;
    if (c.x < cameraX - 50 || c.x > cameraX + canvas.width + 50) continue;
    drawCoin(c.x, c.y);
  }

  // Enemies
  for (let e of enemies) {
    if (e.x + e.w < cameraX - 100 || e.x > cameraX + canvas.width + 200) continue;
    drawEnemy(e);
  }

  // Player (blink while invincible)
  if (player.alive) {
    if (invincibleTimer > 0) {
      ctx.globalAlpha = Math.sin(gameTime * 12) > 0 ? 1 : 0.25;
    }
    drawPlayer();
    ctx.globalAlpha = 1;
  }

  // Particles
  for (let p of particles) {
    ctx.globalAlpha = clamp(p.life * 2, 0, 1);
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
  }
  ctx.globalAlpha = 1;

  ctx.restore(); // camera

  // Ground
  drawGround();

  // Sidewalk
  drawSidewalk();

  ctx.restore(); // shake

  // UI
  drawUI();
}

// --- Drawing Functions ---

function drawCloud(x, y, w, h) {
  ctx.fillStyle = 'rgba(255,255,255,0.85)';
  ctx.beginPath();
  ctx.ellipse(x + w * 0.3, y + h * 0.6, w * 0.3, h * 0.5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(x + w * 0.55, y + h * 0.35, w * 0.28, h * 0.55, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(x + w * 0.75, y + h * 0.55, w * 0.25, h * 0.45, 0, 0, Math.PI * 2);
  ctx.fill();
}

function drawBuilding(b) {
  // Main structure
  ctx.fillStyle = b.color;
  ctx.fillRect(b.x, b.y, b.w, b.h);

  // Outline
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 2;
  ctx.strokeRect(b.x, b.y, b.w, b.h);

  // Brick lines
  ctx.strokeStyle = 'rgba(0,0,0,0.15)';
  ctx.lineWidth = 1;
  for (let row = 0; row < b.h; row += 16) {
    ctx.beginPath();
    ctx.moveTo(b.x, b.y + row);
    ctx.lineTo(b.x + b.w, b.y + row);
    ctx.stroke();
    let offset = (Math.floor(row / 16) % 2) * 20;
    for (let col = offset; col < b.w; col += 40) {
      ctx.beginPath();
      ctx.moveTo(b.x + col, b.y + row);
      ctx.lineTo(b.x + col, b.y + row + 16);
      ctx.stroke();
    }
  }

  // Windows
  for (let win of b.windows) {
    ctx.fillStyle = win.lit ? '#FFFDE7' : '#1a1a2e';
    ctx.fillRect(b.x + win.x, b.y + win.y, 18, 24);
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(b.x + win.x, b.y + win.y, 18, 24);
    // Window cross
    ctx.beginPath();
    ctx.moveTo(b.x + win.x + 9, b.y + win.y);
    ctx.lineTo(b.x + win.x + 9, b.y + win.y + 24);
    ctx.moveTo(b.x + win.x, b.y + win.y + 12);
    ctx.lineTo(b.x + win.x + 18, b.y + win.y + 12);
    ctx.stroke();
  }

  // Roof detail
  ctx.fillStyle = '#333';
  ctx.fillRect(b.x - 3, b.y - 4, b.w + 6, 6);
}

function drawPlatform(p) {
  if (p.type === 'roof') return; // Roofs are drawn with buildings
  if (p.type === 'ledge') {
    ctx.fillStyle = '#555';
    ctx.fillRect(p.x, p.y, p.w, p.h);
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.strokeRect(p.x, p.y, p.w, p.h);
    // Railing
    ctx.strokeStyle = '#777';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(p.x, p.y - 15);
    ctx.lineTo(p.x + p.w, p.y - 15);
    ctx.stroke();
    for (let i = 0; i <= p.w; i += 12) {
      ctx.beginPath();
      ctx.moveTo(p.x + i, p.y);
      ctx.lineTo(p.x + i, p.y - 15);
      ctx.stroke();
    }
  } else {
    // Floating platform
    ctx.fillStyle = '#6B4226';
    ctx.fillRect(p.x, p.y, p.w, p.h);
    ctx.strokeStyle = '#3E2723';
    ctx.lineWidth = 2;
    ctx.strokeRect(p.x, p.y, p.w, p.h);
    ctx.fillStyle = '#4E342E';
    ctx.fillRect(p.x + 2, p.y + 2, p.w - 4, 3);
  }
}

function drawWater(w) {
  ctx.fillStyle = 'rgba(30,100,180,0.6)';
  ctx.fillRect(w.x, w.y, w.w, w.h);
  // Waves
  ctx.strokeStyle = 'rgba(255,255,255,0.4)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i = 0; i < w.w; i += 4) {
    let wy = w.y + Math.sin((i + w.waveOffset + gameTime * 60) * 0.08) * 3;
    if (i === 0) ctx.moveTo(w.x + i, wy);
    else ctx.lineTo(w.x + i, wy);
  }
  ctx.stroke();
}

function drawCoin(x, y) {
  let bob = Math.sin(gameTime * 4 + x * 0.1) * 3;
  ctx.fillStyle = '#FFD700';
  ctx.strokeStyle = '#B8860B';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x, y + bob, COIN_SIZE / 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();
  // Dollar sign
  ctx.fillStyle = '#B8860B';
  ctx.font = 'bold 10px monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('$', x, y + bob + 1);
}

function drawGround() {
  let gy = groundY();
  // Street
  ctx.fillStyle = '#444';
  ctx.fillRect(0, gy, canvas.width, canvas.height - gy);
  // Road markings
  ctx.strokeStyle = '#FFD700';
  ctx.lineWidth = 2;
  ctx.setLineDash([20, 15]);
  ctx.beginPath();
  ctx.moveTo(0, gy + (canvas.height - gy) / 2);
  ctx.lineTo(canvas.width, gy + (canvas.height - gy) / 2);
  ctx.stroke();
  ctx.setLineDash([]);
  // Curb
  ctx.fillStyle = '#777';
  ctx.fillRect(0, gy, canvas.width, 5);
}

function drawSidewalk() {
  let gy = groundY();
  ctx.fillStyle = '#999';
  ctx.fillRect(0, gy - 8, canvas.width, 8);
  // Sidewalk cracks
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 1;
  for (let i = 0; i < canvas.width; i += 40) {
    let offset = ((i + cameraX * 0.95) % 40);
    ctx.beginPath();
    ctx.moveTo(i - offset, gy - 8);
    ctx.lineTo(i - offset, gy);
    ctx.stroke();
  }
}

// --- Player Drawing ---
function drawPlayer() {
  let px = player.x, py = player.y;
  let pw = player.width, ph = player.height;
  let stage = getStage();
  let f = player.facing;

  ctx.save();
  ctx.translate(px + pw / 2, py + ph);
  ctx.scale(f, 1);

  // Color scheme per stage
  let skinColor = '#FDBCB4';
  let shirtColor, pantsColor, hairColor;
  switch (stage) {
    case 'child':
      shirtColor = '#FF6B6B'; pantsColor = '#4ECDC4'; hairColor = '#5D4037';
      break;
    case 'teen':
      shirtColor = '#45B7D1'; pantsColor = '#2C3E50'; hairColor = '#3E2723';
      break;
    case 'youngadult':
      shirtColor = '#6C5CE7'; pantsColor = '#2D3436'; hairColor = '#2C1810';
      break;
    case 'adult':
      shirtColor = '#E17055'; pantsColor = '#2D3436'; hairColor = '#1B1410';
      break;
  }

  let headR = pw * 0.38;
  let bodyTop = -ph + headR * 2 + 2;
  let bodyH = ph * 0.35;
  let legH = ph * 0.3;

  let walkOffset = 0;
  if (!player.onGround) walkOffset = 0;
  else if (Math.abs(player.vx) > 0.5) walkOffset = Math.sin(player.walkFrame * Math.PI / 2) * 4;

  // Legs
  ctx.fillStyle = pantsColor;
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 2;
  // Left leg
  ctx.fillRect(-pw * 0.3, -legH - 2 + walkOffset * 0.5, pw * 0.28, legH);
  ctx.strokeRect(-pw * 0.3, -legH - 2 + walkOffset * 0.5, pw * 0.28, legH);
  // Right leg
  ctx.fillRect(pw * 0.05, -legH - 2 - walkOffset * 0.5, pw * 0.28, legH);
  ctx.strokeRect(pw * 0.05, -legH - 2 - walkOffset * 0.5, pw * 0.28, legH);

  // Shoes
  ctx.fillStyle = '#222';
  ctx.fillRect(-pw * 0.32, -3 + walkOffset * 0.5, pw * 0.34, 4);
  ctx.fillRect(pw * 0.03, -3 - walkOffset * 0.5, pw * 0.34, 4);

  // Body
  ctx.fillStyle = shirtColor;
  ctx.fillRect(-pw * 0.4, bodyTop, pw * 0.8, bodyH);
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 2;
  ctx.strokeRect(-pw * 0.4, bodyTop, pw * 0.8, bodyH);

  // Arms
  let armSwing = Math.sin(player.walkFrame * Math.PI / 2) * 6;
  ctx.fillStyle = shirtColor;
  // Left arm
  ctx.save();
  ctx.translate(-pw * 0.4, bodyTop + 3);
  ctx.rotate((-15 + armSwing) * Math.PI / 180);
  ctx.fillRect(-4, 0, 6, bodyH * 0.8);
  ctx.strokeRect(-4, 0, 6, bodyH * 0.8);
  // Hand
  ctx.fillStyle = skinColor;
  ctx.fillRect(-3, bodyH * 0.75, 5, 5);
  ctx.restore();
  // Right arm
  ctx.save();
  ctx.translate(pw * 0.4, bodyTop + 3);
  ctx.rotate((15 - armSwing) * Math.PI / 180);
  ctx.fillRect(-2, 0, 6, bodyH * 0.8);
  ctx.strokeRect(-2, 0, 6, bodyH * 0.8);
  ctx.fillStyle = skinColor;
  ctx.fillRect(-1, bodyH * 0.75, 5, 5);
  ctx.restore();

  // Head
  let headY = -ph + headR;
  ctx.fillStyle = skinColor;
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(0, headY, headR, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();

  // Hair
  ctx.fillStyle = hairColor;
  ctx.beginPath();
  ctx.arc(0, headY - 2, headR + 1, Math.PI, Math.PI * 2);
  ctx.fill();
  if (stage === 'teen' || stage === 'youngadult') {
    ctx.fillRect(-headR - 2, headY - 4, 5, 8);
  }

  // Eyes
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.arc(headR * 0.25, headY - 2, 2, 0, Math.PI * 2);
  ctx.fill();
  // Eyebrow
  ctx.strokeStyle = hairColor;
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(headR * 0.1, headY - 6);
  ctx.lineTo(headR * 0.45, headY - 7);
  ctx.stroke();

  // Mouth
  ctx.strokeStyle = '#C0392B';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(headR * 0.2, headY + headR * 0.4, 3, 0, Math.PI);
  ctx.stroke();

  ctx.restore();
}

// --- Enemy Drawing ---
function drawEnemy(e) {
  if (e.type === 'bigfoot') drawBigfoot(e);
  if (e.type === 'nessie') drawNessie(e);
  if (e.type === 'godzilla') drawGodzilla(e);
}

function drawBigfoot(e) {
  ctx.save();
  ctx.translate(e.x + e.w / 2, e.y + e.h);

  let dir = e.vx > 0 ? 1 : -1;
  ctx.scale(dir, 1);
  let walk = Math.sin(e.frame * Math.PI / 2) * 3;

  // Feet
  ctx.fillStyle = '#5D4037';
  ctx.fillRect(-16, -6 + walk, 14, 8);
  ctx.fillRect(4, -6 - walk, 14, 8);

  // Legs (furry)
  ctx.fillStyle = '#6D4C41';
  ctx.fillRect(-14, -e.h * 0.4 + walk, 12, e.h * 0.35);
  ctx.fillRect(4, -e.h * 0.4 - walk, 12, e.h * 0.35);

  // Body
  ctx.fillStyle = '#795548';
  ctx.beginPath();
  ctx.ellipse(0, -e.h * 0.55, e.w * 0.42, e.h * 0.3, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#3E2723';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Arms
  let armSwing = Math.sin(e.frame * Math.PI / 2) * 10;
  ctx.save();
  ctx.translate(-e.w * 0.4, -e.h * 0.6);
  ctx.rotate((-20 + armSwing) * Math.PI / 180);
  ctx.fillStyle = '#795548';
  ctx.fillRect(-4, 0, 8, e.h * 0.35);
  ctx.restore();
  ctx.save();
  ctx.translate(e.w * 0.4, -e.h * 0.6);
  ctx.rotate((20 - armSwing) * Math.PI / 180);
  ctx.fillStyle = '#795548';
  ctx.fillRect(-4, 0, 8, e.h * 0.35);
  ctx.restore();

  // Head
  ctx.fillStyle = '#795548';
  ctx.beginPath();
  ctx.arc(0, -e.h * 0.78, e.w * 0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#3E2723';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Face
  ctx.fillStyle = '#A1887F';
  ctx.beginPath();
  ctx.ellipse(3, -e.h * 0.76, e.w * 0.15, e.w * 0.18, 0, 0, Math.PI * 2);
  ctx.fill();

  // Eyes
  ctx.fillStyle = '#FFF';
  ctx.beginPath();
  ctx.arc(5, -e.h * 0.82, 4, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.arc(6, -e.h * 0.82, 2, 0, Math.PI * 2);
  ctx.fill();

  // Mouth (goofy grin)
  ctx.strokeStyle = '#3E2723';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(5, -e.h * 0.72, 6, 0.1, Math.PI - 0.1);
  ctx.stroke();

  ctx.restore();
}

function drawNessie(e) {
  if (!e.emerged) {
    // Just show ripples
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 2;
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.ellipse(e.x + e.w / 2, e.baseY + 5, 15 + i * 10, 3 + i * 1.5, 0, 0, Math.PI * 2);
      ctx.stroke();
    }
    return;
  }

  ctx.save();
  ctx.translate(e.x + e.w / 2, e.y + e.h / 2);

  // Neck (curved)
  ctx.strokeStyle = '#2E7D32';
  ctx.lineWidth = 12;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(-10, 15);
  ctx.quadraticCurveTo(-5, -10, 0, -20);
  ctx.stroke();

  // Body humps
  ctx.fillStyle = '#388E3C';
  ctx.beginPath();
  ctx.ellipse(-15, 10, 18, 10, -0.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(10, 12, 14, 8, 0.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#1B5E20';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.ellipse(-15, 10, 18, 10, -0.2, 0, Math.PI * 2);
  ctx.stroke();
  ctx.beginPath();
  ctx.ellipse(10, 12, 14, 8, 0.2, 0, Math.PI * 2);
  ctx.stroke();

  // Head
  ctx.fillStyle = '#4CAF50';
  ctx.beginPath();
  ctx.ellipse(2, -25, 10, 8, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#1B5E20';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Eye
  ctx.fillStyle = '#FFF';
  ctx.beginPath();
  ctx.arc(7, -27, 4, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.arc(8, -27, 2, 0, Math.PI * 2);
  ctx.fill();

  // Smile
  ctx.strokeStyle = '#1B5E20';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(7, -22, 4, 0.2, Math.PI - 0.2);
  ctx.stroke();

  // Spots
  ctx.fillStyle = '#66BB6A';
  ctx.beginPath(); ctx.arc(-18, 6, 3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(-10, 12, 2.5, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(8, 8, 2.5, 0, Math.PI * 2); ctx.fill();

  ctx.restore();
}

function drawGodzilla(e) {
  ctx.save();
  ctx.translate(e.x + e.w / 2, e.y + e.h);

  let stomp = Math.sin(e.stompTimer * Math.PI * 4) * 3;

  // Tail
  ctx.fillStyle = '#2E7D32';
  ctx.strokeStyle = '#1B5E20';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(25, -30);
  ctx.quadraticCurveTo(60, -40, 80, -20);
  ctx.quadraticCurveTo(60, -25, 25, -15);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // Legs
  ctx.fillStyle = '#2E7D32';
  ctx.fillRect(-30, -50 + stomp, 22, 52 - stomp);
  ctx.fillRect(10, -50 - stomp, 22, 52 + stomp);
  ctx.strokeStyle = '#1B5E20';
  ctx.lineWidth = 2;
  ctx.strokeRect(-30, -50 + stomp, 22, 52 - stomp);
  ctx.strokeRect(10, -50 - stomp, 22, 52 + stomp);

  // Feet
  ctx.fillStyle = '#1B5E20';
  ctx.fillRect(-35, -3 + stomp, 30, 6);
  ctx.fillRect(7, -3 - stomp, 30, 6);

  // Body
  ctx.fillStyle = '#388E3C';
  ctx.beginPath();
  ctx.ellipse(0, -e.h * 0.5, e.w * 0.38, e.h * 0.35, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#1B5E20';
  ctx.lineWidth = 3;
  ctx.stroke();

  // Belly
  ctx.fillStyle = '#A5D6A7';
  ctx.beginPath();
  ctx.ellipse(0, -e.h * 0.45, e.w * 0.22, e.h * 0.25, 0, 0, Math.PI * 2);
  ctx.fill();

  // Arms (small T-rex arms - cartoony)
  ctx.fillStyle = '#388E3C';
  ctx.save();
  ctx.translate(-e.w * 0.3, -e.h * 0.55);
  ctx.rotate(-30 * Math.PI / 180);
  ctx.fillRect(0, 0, 6, 20);
  ctx.restore();
  ctx.save();
  ctx.translate(e.w * 0.15, -e.h * 0.55);
  ctx.rotate(30 * Math.PI / 180);
  ctx.fillRect(0, 0, 6, 20);
  ctx.restore();

  // Dorsal spines
  ctx.fillStyle = '#1B5E20';
  for (let i = 0; i < 5; i++) {
    let sx = -10 + i * 8;
    let sy = -e.h * 0.7 - 10 + Math.abs(i - 2) * 5;
    ctx.beginPath();
    ctx.moveTo(sx - 5, -e.h * 0.65 + i * 3);
    ctx.lineTo(sx, sy);
    ctx.lineTo(sx + 5, -e.h * 0.65 + i * 3);
    ctx.closePath();
    ctx.fill();
  }

  // Head
  ctx.fillStyle = '#388E3C';
  ctx.beginPath();
  ctx.ellipse(-5, -e.h * 0.82, e.w * 0.25, e.h * 0.12, -0.1, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#1B5E20';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Snout
  ctx.fillStyle = '#2E7D32';
  ctx.beginPath();
  ctx.ellipse(-20, -e.h * 0.8, 15, 8, -0.1, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();

  // Eye
  ctx.fillStyle = '#FFEB3B';
  ctx.beginPath();
  ctx.arc(-8, -e.h * 0.85, 6, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.arc(-7, -e.h * 0.85, 3, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#1B5E20';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(-8, -e.h * 0.85, 6, 0, Math.PI * 2);
  ctx.stroke();

  // Mouth with teeth
  ctx.strokeStyle = '#1B5E20';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-33, -e.h * 0.78);
  ctx.lineTo(-12, -e.h * 0.76);
  ctx.stroke();
  // Teeth
  ctx.fillStyle = '#FFF';
  for (let i = 0; i < 4; i++) {
    let tx = -32 + i * 5;
    ctx.beginPath();
    ctx.moveTo(tx, -e.h * 0.78);
    ctx.lineTo(tx + 2, -e.h * 0.75);
    ctx.lineTo(tx + 4, -e.h * 0.78);
    ctx.closePath();
    ctx.fill();
  }

  ctx.restore();
}

// --- UI ---
function drawUI() {
  if (gameState === 'playing') {
    // Age display
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    roundRect(10, 10, 150, 42, 8);
    ctx.fill();
    ctx.fillStyle = '#FFF';
    ctx.font = 'bold 22px Arial, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(`Age: ${age}`, 20, 18);

    // Age progress bar
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.fillRect(20, 42, 130, 5);
    let ageProgress = (gameTime % AGE_DURATION) / AGE_DURATION;
    let barColor = age < 13 ? '#4CAF50' : age < 18 ? '#2196F3' : age < 25 ? '#9C27B0' : '#FF5722';
    ctx.fillStyle = barColor;
    ctx.fillRect(20, 42, 130 * ageProgress, 5);

    // Coins
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    roundRect(170, 10, 130, 42, 8);
    ctx.fill();
    // Coin icon
    ctx.fillStyle = '#FFD700';
    ctx.beginPath();
    ctx.arc(190, 30, 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#B8860B';
    ctx.font = 'bold 10px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('$', 190, 31);
    // Count
    ctx.fillStyle = '#FFF';
    ctx.font = 'bold 20px Arial, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(`${coins}`, 206, 19);

    // Stage label
    let stageLabel = { child: 'Child', teen: 'Teenager', youngadult: 'Young Adult', adult: 'Adult' }[getStage()];
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.font = '14px Arial, sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(stageLabel, canvas.width - 15, 20);

    // Invincibility indicator
    if (invincibleTimer > 0) {
      let pulse = Math.sin(gameTime * 8) * 0.3 + 0.7;
      ctx.fillStyle = `rgba(100,200,255,${pulse})`;
      ctx.font = 'bold 16px Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('SHIELD ACTIVE', canvas.width / 2, 30);
    }

    // Controls hint (fade out after a few seconds)
    if (gameTime < 6) {
      let alpha = gameTime < 4 ? 0.7 : 0.7 * (1 - (gameTime - 4) / 2);
      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
      ctx.font = '14px Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Arrow Keys / WASD to move  |  Space / Up / W to jump', canvas.width / 2, canvas.height - 20);
    }
  }

  if (gameState === 'menu') drawMenuScreen();
  if (gameState === 'gameover') drawGameOverScreen();
  if (gameState === 'victory') drawVictoryScreen();
}

function roundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

function drawMenuScreen() {
  // Background
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // City silhouette
  ctx.fillStyle = '#16213e';
  let bx = 0;
  while (bx < canvas.width) {
    let bw = 40 + Math.random() * 80;
    let bh = 80 + Math.sin(bx * 0.02) * 60 + Math.random() * 100;
    ctx.fillRect(bx, canvas.height - bh - 60, bw, bh + 60);
    bx += bw + 5;
  }

  // Ground
  ctx.fillStyle = '#333';
  ctx.fillRect(0, canvas.height - 60, canvas.width, 60);

  // Stars
  ctx.fillStyle = '#FFF';
  for (let i = 0; i < 60; i++) {
    let sx = (i * 137.5) % canvas.width;
    let sy = (i * 97.3) % (canvas.height - 200) + 20;
    let ss = 1 + Math.sin(gameTime * 2 + i) * 0.5;
    ctx.beginPath();
    ctx.arc(sx, sy, ss, 0, Math.PI * 2);
    ctx.fill();
  }

  // Title
  ctx.fillStyle = '#FFD700';
  ctx.font = 'bold 56px Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText("Theo's Game", canvas.width / 2, canvas.height * 0.28);

  ctx.fillStyle = '#CCC';
  ctx.font = '20px Arial, sans-serif';
  ctx.fillText('Survive to 30!', canvas.width / 2, canvas.height * 0.38);

  // Cartoony monsters in background
  drawMenuBigfoot(canvas.width * 0.15, canvas.height - 110);
  drawMenuNessie(canvas.width * 0.5, canvas.height - 85);
  drawMenuGodzilla(canvas.width * 0.82, canvas.height - 200);

  // Play button
  let btnW = 200, btnH = 55;
  let btnX = canvas.width / 2 - btnW / 2;
  let btnY = canvas.height * 0.55;
  let hover = mouseInRect(btnX, btnY, btnW, btnH);

  ctx.fillStyle = hover ? '#4CAF50' : '#388E3C';
  roundRect(btnX, btnY, btnW, btnH, 12);
  ctx.fill();
  ctx.strokeStyle = '#2E7D32';
  ctx.lineWidth = 3;
  roundRect(btnX, btnY, btnW, btnH, 12);
  ctx.stroke();

  ctx.fillStyle = '#FFF';
  ctx.font = 'bold 28px Arial, sans-serif';
  ctx.fillText('PLAY', canvas.width / 2, btnY + btnH / 2);

  // Instructions
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.font = '14px Arial, sans-serif';
  ctx.fillText('Dodge monsters. Collect coins. Reach age 30.', canvas.width / 2, btnY + btnH + 35);
  ctx.fillText('Arrow Keys / WASD to move  |  Space / Up / W to jump', canvas.width / 2, btnY + btnH + 55);
}

function drawMenuBigfoot(x, y) {
  ctx.fillStyle = '#795548';
  ctx.beginPath();
  ctx.ellipse(x, y - 15, 18, 22, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#5D4037';
  ctx.beginPath();
  ctx.arc(x, y - 35, 12, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#FFF';
  ctx.beginPath(); ctx.arc(x + 3, y - 38, 3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#222';
  ctx.beginPath(); ctx.arc(x + 4, y - 38, 1.5, 0, Math.PI * 2); ctx.fill();
}

function drawMenuNessie(x, y) {
  ctx.fillStyle = '#388E3C';
  ctx.beginPath();
  ctx.ellipse(x - 10, y, 16, 8, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(x + 12, y + 2, 12, 7, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#2E7D32';
  ctx.lineWidth = 8;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(x - 10, y);
  ctx.quadraticCurveTo(x - 8, y - 20, x - 5, y - 25);
  ctx.stroke();
  ctx.fillStyle = '#4CAF50';
  ctx.beginPath();
  ctx.ellipse(x - 4, y - 28, 7, 5, -0.2, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#FFF';
  ctx.beginPath(); ctx.arc(x - 1, y - 30, 2.5, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#222';
  ctx.beginPath(); ctx.arc(x, y - 30, 1.2, 0, Math.PI * 2); ctx.fill();
}

function drawMenuGodzilla(x, y) {
  ctx.fillStyle = '#388E3C';
  ctx.beginPath();
  ctx.ellipse(x, y + 30, 28, 45, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#A5D6A7';
  ctx.beginPath();
  ctx.ellipse(x, y + 35, 16, 30, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#388E3C';
  ctx.beginPath();
  ctx.ellipse(x - 2, y - 15, 16, 10, -0.1, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#FFEB3B';
  ctx.beginPath(); ctx.arc(x + 3, y - 18, 4, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#222';
  ctx.beginPath(); ctx.arc(x + 4, y - 18, 2, 0, Math.PI * 2); ctx.fill();
  // Spines
  ctx.fillStyle = '#1B5E20';
  for (let i = 0; i < 4; i++) {
    ctx.beginPath();
    ctx.moveTo(x - 5 + i * 5, y - 5 + i * 8);
    ctx.lineTo(x - 2 + i * 5, y - 20 + i * 4);
    ctx.lineTo(x + 1 + i * 5, y - 5 + i * 8);
    ctx.closePath();
    ctx.fill();
  }
}

function drawGameOverScreen() {
  ctx.fillStyle = 'rgba(0,0,0,0.75)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Skull icon (cartoony)
  let cx = canvas.width / 2, cy = canvas.height * 0.25;
  ctx.fillStyle = '#FFF';
  ctx.beginPath();
  ctx.arc(cx, cy, 30, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#222';
  ctx.beginPath(); ctx.arc(cx - 10, cy - 5, 6, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + 10, cy - 5, 6, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(cx - 5, cy + 12);
  ctx.lineTo(cx + 5, cy + 12);
  ctx.lineTo(cx + 3, cy + 18);
  ctx.lineTo(cx - 3, cy + 18);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = '#FF4444';
  ctx.font = 'bold 42px Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('GAME OVER', canvas.width / 2, canvas.height * 0.4);

  ctx.fillStyle = '#FFF';
  ctx.font = '20px Arial, sans-serif';

  // Word wrap death message
  let lines = wrapText(deathMessage, 500);
  for (let i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], canvas.width / 2, canvas.height * 0.5 + i * 28);
  }

  ctx.fillStyle = '#FFD700';
  ctx.font = '18px Arial, sans-serif';
  ctx.fillText(`Coins collected: ${coins}`, canvas.width / 2, canvas.height * 0.6);

  // Restart button
  let btnW = 200, btnH = 50;
  let btnX = canvas.width / 2 - btnW / 2;
  let btnY = canvas.height * 0.68;
  let hover = mouseInRect(btnX, btnY, btnW, btnH);

  ctx.fillStyle = hover ? '#E53935' : '#C62828';
  roundRect(btnX, btnY, btnW, btnH, 10);
  ctx.fill();
  ctx.fillStyle = '#FFF';
  ctx.font = 'bold 22px Arial, sans-serif';
  ctx.fillText('RESTART', canvas.width / 2, btnY + btnH / 2);
}

function drawVictoryScreen() {
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Trophy
  let cx = canvas.width / 2;
  ctx.fillStyle = '#FFD700';
  ctx.beginPath();
  ctx.moveTo(cx - 20, canvas.height * 0.18);
  ctx.lineTo(cx + 20, canvas.height * 0.18);
  ctx.lineTo(cx + 15, canvas.height * 0.28);
  ctx.lineTo(cx - 15, canvas.height * 0.28);
  ctx.closePath();
  ctx.fill();
  ctx.fillRect(cx - 5, canvas.height * 0.28, 10, 12);
  ctx.fillRect(cx - 15, canvas.height * 0.30 + 8, 30, 6);
  // Handles
  ctx.strokeStyle = '#FFD700';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(cx - 22, canvas.height * 0.22, 8, Math.PI * 0.5, Math.PI * 1.5);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(cx + 22, canvas.height * 0.22, 8, -Math.PI * 0.5, Math.PI * 0.5);
  ctx.stroke();

  ctx.fillStyle = '#4CAF50';
  ctx.font = 'bold 48px Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('YOU SURVIVED!', canvas.width / 2, canvas.height * 0.42);

  ctx.fillStyle = '#FFF';
  ctx.font = '24px Arial, sans-serif';
  ctx.fillText('You made it to age 30!', canvas.width / 2, canvas.height * 0.52);

  ctx.fillStyle = '#FFD700';
  ctx.font = 'bold 22px Arial, sans-serif';
  ctx.fillText(`Coins collected: ${coins}`, canvas.width / 2, canvas.height * 0.60);

  // Restart button
  let btnW = 220, btnH = 50;
  let btnX = canvas.width / 2 - btnW / 2;
  let btnY = canvas.height * 0.68;
  let hover = mouseInRect(btnX, btnY, btnW, btnH);

  ctx.fillStyle = hover ? '#66BB6A' : '#4CAF50';
  roundRect(btnX, btnY, btnW, btnH, 10);
  ctx.fill();
  ctx.fillStyle = '#FFF';
  ctx.font = 'bold 22px Arial, sans-serif';
  ctx.fillText('PLAY AGAIN', canvas.width / 2, btnY + btnH / 2);
}

function wrapText(text, maxWidth) {
  ctx.font = '20px Arial, sans-serif';
  let words = text.split(' ');
  let lines = [];
  let line = '';
  for (let w of words) {
    let test = line ? line + ' ' + w : w;
    if (ctx.measureText(test).width > maxWidth) {
      lines.push(line);
      line = w;
    } else {
      line = test;
    }
  }
  if (line) lines.push(line);
  return lines;
}

// --- Mouse / Click ---
let mouseX = 0, mouseY = 0;
canvas.addEventListener('mousemove', e => {
  let rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = e.clientY - rect.top;
});

function mouseInRect(x, y, w, h) {
  return mouseX >= x && mouseX <= x + w && mouseY >= y && mouseY <= y + h;
}

canvas.addEventListener('click', e => {
  let rect = canvas.getBoundingClientRect();
  let cx = e.clientX - rect.left;
  let cy = e.clientY - rect.top;

  if (gameState === 'menu') {
    let btnW = 200, btnH = 55;
    let btnX = canvas.width / 2 - btnW / 2;
    let btnY = canvas.height * 0.55;
    if (cx >= btnX && cx <= btnX + btnW && cy >= btnY && cy <= btnY + btnH) {
      initGame();
      gameState = 'playing';
    }
  }

  if (gameState === 'gameover') {
    let btnW = 200, btnH = 50;
    let btnX = canvas.width / 2 - btnW / 2;
    let btnY = canvas.height * 0.68;
    if (cx >= btnX && cx <= btnX + btnW && cy >= btnY && cy <= btnY + btnH) {
      initGame();
      gameState = 'playing';
    }
  }

  if (gameState === 'victory') {
    let btnW = 220, btnH = 50;
    let btnX = canvas.width / 2 - btnW / 2;
    let btnY = canvas.height * 0.68;
    if (cx >= btnX && cx <= btnX + btnW && cy >= btnY && cy <= btnY + btnH) {
      initGame();
      gameState = 'playing';
    }
  }
});

// --- Touch support for mobile ---
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  let rect = canvas.getBoundingClientRect();
  let touch = e.touches[0];
  mouseX = touch.clientX - rect.left;
  mouseY = touch.clientY - rect.top;
  // Simulate click
  canvas.dispatchEvent(new MouseEvent('click', {
    clientX: touch.clientX,
    clientY: touch.clientY
  }));
});

// --- Game Loop ---
function gameLoop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  let dt = (timestamp - lastTime) / 1000;
  if (dt > 0.1) dt = 0.1; // cap delta
  lastTime = timestamp;

  // Animate menu stars
  if (gameState === 'menu') gameTime += dt;

  update(dt);
  draw();
  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);

</script>
</body>
</html>
